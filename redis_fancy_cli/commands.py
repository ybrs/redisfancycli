commands = {'APPEND': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1). The amortized time complexity is O(1) '
                          'assuming the appended value is small and the '
                          'already present value is of any size, since the '
                          'dynamic string library used by Redis will double '
                          'the free space available on every reallocation.',
            'group': 'string',
            'since': '2.0.0',
            'summary': 'Append a value to a key'},
 'AUTH': {'arguments': [{'name': 'password', 'type': 'string'}],
          'group': 'connection',
          'since': '1.0.0',
          'summary': 'Authenticate to the server'},
 'BGREWRITEAOF': {'group': 'server',
                  'since': '1.0.0',
                  'summary': 'Asynchronously rewrite the append-only file'},
 'BGSAVE': {'group': 'server',
            'since': '1.0.0',
            'summary': 'Asynchronously save the dataset to disk'},
 'BITCOUNT': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': ['start', 'end'],
                             'optional': True,
                             'type': ['integer', 'integer']}],
              'complexity': 'O(N)',
              'group': 'string',
              'since': '2.6.0',
              'summary': 'Count set bits in a string'},
 'BITFIELD': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'command': 'GET',
                             'name': ['type', 'offset'],
                             'optional': True,
                             'type': ['type', 'integer']},
                            {'command': 'SET',
                             'name': ['type', 'offset', 'value'],
                             'optional': True,
                             'type': ['type', 'integer', 'integer']},
                            {'command': 'INCRBY',
                             'name': ['type', 'offset', 'increment'],
                             'optional': True,
                             'type': ['type', 'integer', 'integer']},
                            {'command': 'OVERFLOW',
                             'enum': ['WRAP', 'SAT', 'FAIL'],
                             'optional': True,
                             'type': 'enum'}],
              'complexity': 'O(1) for each subcommand specified',
              'group': 'string',
              'since': '3.2.0',
              'summary': 'Perform arbitrary bitfield integer operations on '
                         'strings'},
 'BITOP': {'arguments': [{'name': 'operation', 'type': 'string'},
                         {'name': 'destkey', 'type': 'key'},
                         {'multiple': True, 'name': 'key', 'type': 'key'}],
           'complexity': 'O(N)',
           'group': 'string',
           'since': '2.6.0',
           'summary': 'Perform bitwise operations between strings'},
 'BITPOS': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'bit', 'type': 'integer'},
                          {'name': 'start',
                           'optional': True,
                           'type': 'integer'},
                          {'name': 'end', 'optional': True, 'type': 'integer'}],
            'complexity': 'O(N)',
            'group': 'string',
            'since': '2.8.7',
            'summary': 'Find first bit set or clear in a string'},
 'BLPOP': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'},
                         {'name': 'timeout', 'type': 'integer'}],
           'complexity': 'O(1)',
           'group': 'list',
           'since': '2.0.0',
           'summary': 'Remove and get the first element in a list, or block '
                      'until one is available'},
 'BRPOP': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'},
                         {'name': 'timeout', 'type': 'integer'}],
           'complexity': 'O(1)',
           'group': 'list',
           'since': '2.0.0',
           'summary': 'Remove and get the last element in a list, or block '
                      'until one is available'},
 'BRPOPLPUSH': {'arguments': [{'name': 'source', 'type': 'key'},
                              {'name': 'destination', 'type': 'key'},
                              {'name': 'timeout', 'type': 'integer'}],
                'complexity': 'O(1)',
                'group': 'list',
                'since': '2.2.0',
                'summary': 'Pop a value from a list, push it to another list '
                           'and return it; or block until one is available'},
 'BZPOPMAX': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'},
                            {'name': 'timeout', 'type': 'integer'}],
              'complexity': 'O(log(N)) with N being the number of elements in '
                            'the sorted set.',
              'group': 'sorted_set',
              'since': '5.0.0',
              'summary': 'Remove and return the member with the highest score '
                         'from one or more sorted sets, or block until one is '
                         'available'},
 'BZPOPMIN': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'},
                            {'name': 'timeout', 'type': 'integer'}],
              'complexity': 'O(log(N)) with N being the number of elements in '
                            'the sorted set.',
              'group': 'sorted_set',
              'since': '5.0.0',
              'summary': 'Remove and return the member with the lowest score '
                         'from one or more sorted sets, or block until one is '
                         'available'},
 'CLIENT GETNAME': {'complexity': 'O(1)',
                    'group': 'server',
                    'since': '2.6.9',
                    'summary': 'Get the current connection name'},
 'CLIENT ID': {'complexity': 'O(1)',
               'group': 'server',
               'since': '5.0.0',
               'summary': 'Returns the client ID for the current connection'},
 'CLIENT KILL': {'arguments': [{'name': 'ip:port',
                                'optional': True,
                                'type': 'string'},
                               {'command': 'ID',
                                'name': 'client-id',
                                'optional': True,
                                'type': 'integer'},
                               {'command': 'TYPE',
                                'enum': ['normal', 'master', 'slave', 'pubsub'],
                                'optional': True,
                                'type': 'enum'},
                               {'command': 'ADDR',
                                'name': 'ip:port',
                                'optional': True,
                                'type': 'string'},
                               {'command': 'SKIPME',
                                'name': 'yes/no',
                                'optional': True,
                                'type': 'string'}],
                 'complexity': 'O(N) where N is the number of client '
                               'connections',
                 'group': 'server',
                 'since': '2.4.0',
                 'summary': 'Kill the connection of a client'},
 'CLIENT LIST': {'arguments': [{'command': 'TYPE',
                                'enum': ['normal',
                                         'master',
                                         'replica',
                                         'pubsub'],
                                'optional': True,
                                'type': 'enum'}],
                 'complexity': 'O(N) where N is the number of client '
                               'connections',
                 'group': 'server',
                 'since': '2.4.0',
                 'summary': 'Get the list of client connections'},
 'CLIENT PAUSE': {'arguments': [{'name': 'timeout', 'type': 'integer'}],
                  'complexity': 'O(1)',
                  'group': 'server',
                  'since': '2.9.50',
                  'summary': 'Stop processing commands from clients for some '
                             'time'},
 'CLIENT REPLY': {'arguments': [{'enum': ['ON', 'OFF', 'SKIP'],
                                 'name': 'reply-mode',
                                 'type': 'enum'}],
                  'complexity': 'O(1)',
                  'group': 'server',
                  'since': '3.2',
                  'summary': 'Instruct the server whether to reply to '
                             'commands'},
 'CLIENT SETNAME': {'arguments': [{'name': 'connection-name',
                                   'type': 'string'}],
                    'complexity': 'O(1)',
                    'group': 'server',
                    'since': '2.6.9',
                    'summary': 'Set the current connection name'},
 'CLIENT UNBLOCK': {'arguments': [{'name': 'client-id', 'type': 'string'},
                                  {'enum': ['TIMEOUT', 'ERROR'],
                                   'name': 'unblock-type',
                                   'optional': True,
                                   'type': 'enum'}],
                    'complexity': 'O(log N) where N is the number of client '
                                  'connections',
                    'group': 'server',
                    'since': '5.0.0',
                    'summary': 'Unblock a client blocked in a blocking command '
                               'from a different connection'},
 'CLUSTER ADDSLOTS': {'arguments': [{'multiple': True,
                                     'name': 'slot',
                                     'type': 'integer'}],
                      'complexity': 'O(N) where N is the total number of hash '
                                    'slot arguments',
                      'group': 'cluster',
                      'since': '3.0.0',
                      'summary': 'Assign new hash slots to receiving node'},
 'CLUSTER COUNT-FAILURE-REPORTS': {'arguments': [{'name': 'node-id',
                                                  'type': 'string'}],
                                   'complexity': 'O(N) where N is the number '
                                                 'of failure reports',
                                   'group': 'cluster',
                                   'since': '3.0.0',
                                   'summary': 'Return the number of failure '
                                              'reports active for a given '
                                              'node'},
 'CLUSTER COUNTKEYSINSLOT': {'arguments': [{'name': 'slot', 'type': 'integer'}],
                             'complexity': 'O(1)',
                             'group': 'cluster',
                             'since': '3.0.0',
                             'summary': 'Return the number of local keys in '
                                        'the specified hash slot'},
 'CLUSTER DELSLOTS': {'arguments': [{'multiple': True,
                                     'name': 'slot',
                                     'type': 'integer'}],
                      'complexity': 'O(N) where N is the total number of hash '
                                    'slot arguments',
                      'group': 'cluster',
                      'since': '3.0.0',
                      'summary': 'Set hash slots as unbound in receiving node'},
 'CLUSTER FAILOVER': {'arguments': [{'enum': ['FORCE', 'TAKEOVER'],
                                     'name': 'options',
                                     'optional': True,
                                     'type': 'enum'}],
                      'complexity': 'O(1)',
                      'group': 'cluster',
                      'since': '3.0.0',
                      'summary': 'Forces a replica to perform a manual '
                                 'failover of its master.'},
 'CLUSTER FORGET': {'arguments': [{'name': 'node-id', 'type': 'string'}],
                    'complexity': 'O(1)',
                    'group': 'cluster',
                    'since': '3.0.0',
                    'summary': 'Remove a node from the nodes table'},
 'CLUSTER GETKEYSINSLOT': {'arguments': [{'name': 'slot', 'type': 'integer'},
                                         {'name': 'count', 'type': 'integer'}],
                           'complexity': 'O(log(N)) where N is the number of '
                                         'requested keys',
                           'group': 'cluster',
                           'since': '3.0.0',
                           'summary': 'Return local key names in the specified '
                                      'hash slot'},
 'CLUSTER INFO': {'complexity': 'O(1)',
                  'group': 'cluster',
                  'since': '3.0.0',
                  'summary': 'Provides info about Redis Cluster node state'},
 'CLUSTER KEYSLOT': {'arguments': [{'name': 'key', 'type': 'string'}],
                     'complexity': 'O(N) where N is the number of bytes in the '
                                   'key',
                     'group': 'cluster',
                     'since': '3.0.0',
                     'summary': 'Returns the hash slot of the specified key'},
 'CLUSTER MEET': {'arguments': [{'name': 'ip', 'type': 'string'},
                                {'name': 'port', 'type': 'integer'}],
                  'complexity': 'O(1)',
                  'group': 'cluster',
                  'since': '3.0.0',
                  'summary': 'Force a node cluster to handshake with another '
                             'node'},
 'CLUSTER NODES': {'complexity': 'O(N) where N is the total number of Cluster '
                                 'nodes',
                   'group': 'cluster',
                   'since': '3.0.0',
                   'summary': 'Get Cluster config for the node'},
 'CLUSTER REPLICAS': {'arguments': [{'name': 'node-id', 'type': 'string'}],
                      'complexity': 'O(1)',
                      'group': 'cluster',
                      'since': '5.0.0',
                      'summary': 'List replica nodes of the specified master '
                                 'node'},
 'CLUSTER REPLICATE': {'arguments': [{'name': 'node-id', 'type': 'string'}],
                       'complexity': 'O(1)',
                       'group': 'cluster',
                       'since': '3.0.0',
                       'summary': 'Reconfigure a node as a replica of the '
                                  'specified master node'},
 'CLUSTER RESET': {'arguments': [{'enum': ['HARD', 'SOFT'],
                                  'name': 'reset-type',
                                  'optional': True,
                                  'type': 'enum'}],
                   'complexity': 'O(N) where N is the number of known nodes. '
                                 'The command may execute a FLUSHALL as a side '
                                 'effect.',
                   'group': 'cluster',
                   'since': '3.0.0',
                   'summary': 'Reset a Redis Cluster node'},
 'CLUSTER SAVECONFIG': {'complexity': 'O(1)',
                        'group': 'cluster',
                        'since': '3.0.0',
                        'summary': 'Forces the node to save cluster state on '
                                   'disk'},
 'CLUSTER SET-CONFIG-EPOCH': {'arguments': [{'name': 'config-epoch',
                                             'type': 'integer'}],
                              'complexity': 'O(1)',
                              'group': 'cluster',
                              'since': '3.0.0',
                              'summary': 'Set the configuration epoch in a new '
                                         'node'},
 'CLUSTER SETSLOT': {'arguments': [{'name': 'slot', 'type': 'integer'},
                                   {'enum': ['IMPORTING',
                                             'MIGRATING',
                                             'STABLE',
                                             'NODE'],
                                    'name': 'subcommand',
                                    'type': 'enum'},
                                   {'name': 'node-id',
                                    'optional': True,
                                    'type': 'string'}],
                     'complexity': 'O(1)',
                     'group': 'cluster',
                     'since': '3.0.0',
                     'summary': 'Bind a hash slot to a specific node'},
 'CLUSTER SLAVES': {'arguments': [{'name': 'node-id', 'type': 'string'}],
                    'complexity': 'O(1)',
                    'group': 'cluster',
                    'since': '3.0.0',
                    'summary': 'List replica nodes of the specified master '
                               'node'},
 'CLUSTER SLOTS': {'complexity': 'O(N) where N is the total number of Cluster '
                                 'nodes',
                   'group': 'cluster',
                   'since': '3.0.0',
                   'summary': 'Get array of Cluster slot to node mappings'},
 'COMMAND': {'complexity': 'O(N) where N is the total number of Redis commands',
             'group': 'server',
             'since': '2.8.13',
             'summary': 'Get array of Redis command details'},
 'COMMAND COUNT': {'complexity': 'O(1)',
                   'group': 'server',
                   'since': '2.8.13',
                   'summary': 'Get total number of Redis commands'},
 'COMMAND GETKEYS': {'complexity': 'O(N) where N is the number of arguments to '
                                   'the command',
                     'group': 'server',
                     'since': '2.8.13',
                     'summary': 'Extract keys given a full Redis command'},
 'COMMAND INFO': {'arguments': [{'multiple': True,
                                 'name': 'command-name',
                                 'type': 'string'}],
                  'complexity': 'O(N) when N is number of commands to look up',
                  'group': 'server',
                  'since': '2.8.13',
                  'summary': 'Get array of specific Redis command details'},
 'CONFIG GET': {'arguments': [{'name': 'parameter', 'type': 'string'}],
                'group': 'server',
                'since': '2.0.0',
                'summary': 'Get the value of a configuration parameter'},
 'CONFIG RESETSTAT': {'complexity': 'O(1)',
                      'group': 'server',
                      'since': '2.0.0',
                      'summary': 'Reset the stats returned by INFO'},
 'CONFIG REWRITE': {'group': 'server',
                    'since': '2.8.0',
                    'summary': 'Rewrite the configuration file with the in '
                               'memory configuration'},
 'CONFIG SET': {'arguments': [{'name': 'parameter', 'type': 'string'},
                              {'name': 'value', 'type': 'string'}],
                'group': 'server',
                'since': '2.0.0',
                'summary': 'Set a configuration parameter to the given value'},
 'DBSIZE': {'group': 'server',
            'since': '1.0.0',
            'summary': 'Return the number of keys in the selected database'},
 'DEBUG OBJECT': {'arguments': [{'name': 'key', 'type': 'key'}],
                  'group': 'server',
                  'since': '1.0.0',
                  'summary': 'Get debugging information about a key'},
 'DEBUG SEGFAULT': {'group': 'server',
                    'since': '1.0.0',
                    'summary': 'Make the server crash'},
 'DECR': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'string',
          'since': '1.0.0',
          'summary': 'Decrement the integer value of a key by one'},
 'DECRBY': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'decrement', 'type': 'integer'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '1.0.0',
            'summary': 'Decrement the integer value of a key by the given '
                       'number'},
 'DEL': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
         'complexity': 'O(N) where N is the number of keys that will be '
                       'removed. When a key to remove holds a value other than '
                       'a string, the individual complexity for this key is '
                       'O(M) where M is the number of elements in the list, '
                       'set, sorted set or hash. Removing a single key that '
                       'holds a string value is O(1).',
         'group': 'generic',
         'since': '1.0.0',
         'summary': 'Delete a key'},
 'DISCARD': {'group': 'transactions',
             'since': '2.0.0',
             'summary': 'Discard all commands issued after MULTI'},
 'DUMP': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1) to access the key and additional O(N*M) to '
                        'serialized it, where N is the number of Redis objects '
                        'composing the value and M their average size. For '
                        'small string values the time complexity is thus '
                        'O(1)+O(1*M) where M is small, so simply O(1).',
          'group': 'generic',
          'since': '2.6.0',
          'summary': 'Return a serialized version of the value stored at the '
                     'specified key.'},
 'ECHO': {'arguments': [{'name': 'message', 'type': 'string'}],
          'group': 'connection',
          'since': '1.0.0',
          'summary': 'Echo the given string'},
 'EVAL': {'arguments': [{'name': 'script', 'type': 'string'},
                        {'name': 'numkeys', 'type': 'integer'},
                        {'multiple': True, 'name': 'key', 'type': 'key'},
                        {'multiple': True, 'name': 'arg', 'type': 'string'}],
          'complexity': 'Depends on the script that is executed.',
          'group': 'scripting',
          'since': '2.6.0',
          'summary': 'Execute a Lua script server side'},
 'EVALSHA': {'arguments': [{'name': 'sha1', 'type': 'string'},
                           {'name': 'numkeys', 'type': 'integer'},
                           {'multiple': True, 'name': 'key', 'type': 'key'},
                           {'multiple': True, 'name': 'arg', 'type': 'string'}],
             'complexity': 'Depends on the script that is executed.',
             'group': 'scripting',
             'since': '2.6.0',
             'summary': 'Execute a Lua script server side'},
 'EXEC': {'group': 'transactions',
          'since': '1.2.0',
          'summary': 'Execute all commands issued after MULTI'},
 'EXISTS': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
            'complexity': 'O(1)',
            'group': 'generic',
            'since': '1.0.0',
            'summary': 'Determine if a key exists'},
 'EXPIRE': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'seconds', 'type': 'integer'}],
            'complexity': 'O(1)',
            'group': 'generic',
            'since': '1.0.0',
            'summary': "Set a key's time to live in seconds"},
 'EXPIREAT': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'timestamp', 'type': 'posix time'}],
              'complexity': 'O(1)',
              'group': 'generic',
              'since': '1.2.0',
              'summary': 'Set the expiration for a key as a UNIX timestamp'},
 'FLUSHALL': {'arguments': [{'enum': ['ASYNC'],
                             'name': 'async',
                             'optional': True,
                             'type': 'enum'}],
              'group': 'server',
              'since': '1.0.0',
              'summary': 'Remove all keys from all databases'},
 'FLUSHDB': {'arguments': [{'enum': ['ASYNC'],
                            'name': 'async',
                            'optional': True,
                            'type': 'enum'}],
             'group': 'server',
             'since': '1.0.0',
             'summary': 'Remove all keys from the current database'},
 'GEOADD': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'multiple': True,
                           'name': ['longitude', 'latitude', 'member'],
                           'type': ['double', 'double', 'string']}],
            'complexity': 'O(log(N)) for each item added, where N is the '
                          'number of elements in the sorted set.',
            'group': 'geo',
            'since': '3.2.0',
            'summary': 'Add one or more geospatial items in the geospatial '
                       'index represented using a sorted set'},
 'GEODIST': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'member1', 'type': 'string'},
                           {'name': 'member2', 'type': 'string'},
                           {'name': 'unit',
                            'optional': True,
                            'type': 'string'}],
             'complexity': 'O(log(N))',
             'group': 'geo',
             'since': '3.2.0',
             'summary': 'Returns the distance between two members of a '
                        'geospatial index'},
 'GEOHASH': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'multiple': True,
                            'name': 'member',
                            'type': 'string'}],
             'complexity': 'O(log(N)) for each member requested, where N is '
                           'the number of elements in the sorted set.',
             'group': 'geo',
             'since': '3.2.0',
             'summary': 'Returns members of a geospatial index as standard '
                        'geohash strings'},
 'GEOPOS': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'multiple': True,
                           'name': 'member',
                           'type': 'string'}],
            'complexity': 'O(log(N)) for each member requested, where N is the '
                          'number of elements in the sorted set.',
            'group': 'geo',
            'since': '3.2.0',
            'summary': 'Returns longitude and latitude of members of a '
                       'geospatial index'},
 'GEORADIUS': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'longitude', 'type': 'double'},
                             {'name': 'latitude', 'type': 'double'},
                             {'name': 'radius', 'type': 'double'},
                             {'enum': ['m', 'km', 'ft', 'mi'],
                              'name': 'unit',
                              'type': 'enum'},
                             {'enum': ['WITHCOORD'],
                              'name': 'withcoord',
                              'optional': True,
                              'type': 'enum'},
                             {'enum': ['WITHDIST'],
                              'name': 'withdist',
                              'optional': True,
                              'type': 'enum'},
                             {'enum': ['WITHHASH'],
                              'name': 'withhash',
                              'optional': True,
                              'type': 'enum'},
                             {'command': 'COUNT',
                              'name': 'count',
                              'optional': True,
                              'type': 'integer'},
                             {'enum': ['ASC', 'DESC'],
                              'name': 'order',
                              'optional': True,
                              'type': 'enum'},
                             {'command': 'STORE',
                              'name': 'key',
                              'optional': True,
                              'type': 'key'},
                             {'command': 'STOREDIST',
                              'name': 'key',
                              'optional': True,
                              'type': 'key'}],
               'complexity': 'O(N+log(M)) where N is the number of elements '
                             'inside the bounding box of the circular area '
                             'delimited by center and radius and M is the '
                             'number of items inside the index.',
               'group': 'geo',
               'since': '3.2.0',
               'summary': 'Query a sorted set representing a geospatial index '
                          'to fetch members matching a given maximum distance '
                          'from a point'},
 'GEORADIUSBYMEMBER': {'arguments': [{'name': 'key', 'type': 'key'},
                                     {'name': 'member', 'type': 'string'},
                                     {'name': 'radius', 'type': 'double'},
                                     {'enum': ['m', 'km', 'ft', 'mi'],
                                      'name': 'unit',
                                      'type': 'enum'},
                                     {'enum': ['WITHCOORD'],
                                      'name': 'withcoord',
                                      'optional': True,
                                      'type': 'enum'},
                                     {'enum': ['WITHDIST'],
                                      'name': 'withdist',
                                      'optional': True,
                                      'type': 'enum'},
                                     {'enum': ['WITHHASH'],
                                      'name': 'withhash',
                                      'optional': True,
                                      'type': 'enum'},
                                     {'command': 'COUNT',
                                      'name': 'count',
                                      'optional': True,
                                      'type': 'integer'},
                                     {'enum': ['ASC', 'DESC'],
                                      'name': 'order',
                                      'optional': True,
                                      'type': 'enum'},
                                     {'command': 'STORE',
                                      'name': 'key',
                                      'optional': True,
                                      'type': 'key'},
                                     {'command': 'STOREDIST',
                                      'name': 'key',
                                      'optional': True,
                                      'type': 'key'}],
                       'complexity': 'O(N+log(M)) where N is the number of '
                                     'elements inside the bounding box of the '
                                     'circular area delimited by center and '
                                     'radius and M is the number of items '
                                     'inside the index.',
                       'group': 'geo',
                       'since': '3.2.0',
                       'summary': 'Query a sorted set representing a '
                                  'geospatial index to fetch members matching '
                                  'a given maximum distance from a member'},
 'GET': {'arguments': [{'name': 'key', 'type': 'key'}],
         'complexity': 'O(1)',
         'group': 'string',
         'since': '1.0.0',
         'summary': 'Get the value of a key'},
 'GETBIT': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'offset', 'type': 'integer'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '2.2.0',
            'summary': 'Returns the bit value at offset in the string value '
                       'stored at key'},
 'GETRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'start', 'type': 'integer'},
                            {'name': 'end', 'type': 'integer'}],
              'complexity': 'O(N) where N is the length of the returned '
                            'string. The complexity is ultimately determined '
                            'by the returned length, but because creating a '
                            'substring from an existing string is very cheap, '
                            'it can be considered O(1) for small strings.',
              'group': 'string',
              'since': '2.4.0',
              'summary': 'Get a substring of the string stored at a key'},
 'GETSET': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '1.0.0',
            'summary': 'Set the string value of a key and return its old '
                       'value'},
 'HDEL': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'multiple': True, 'name': 'field', 'type': 'string'}],
          'complexity': 'O(N) where N is the number of fields to be removed.',
          'group': 'hash',
          'since': '2.0.0',
          'summary': 'Delete one or more hash fields'},
 'HEXISTS': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'field', 'type': 'string'}],
             'complexity': 'O(1)',
             'group': 'hash',
             'since': '2.0.0',
             'summary': 'Determine if a hash field exists'},
 'HGET': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'field', 'type': 'string'}],
          'complexity': 'O(1)',
          'group': 'hash',
          'since': '2.0.0',
          'summary': 'Get the value of a hash field'},
 'HGETALL': {'arguments': [{'name': 'key', 'type': 'key'}],
             'complexity': 'O(N) where N is the size of the hash.',
             'group': 'hash',
             'since': '2.0.0',
             'summary': 'Get all the fields and values in a hash'},
 'HINCRBY': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'field', 'type': 'string'},
                           {'name': 'increment', 'type': 'integer'}],
             'complexity': 'O(1)',
             'group': 'hash',
             'since': '2.0.0',
             'summary': 'Increment the integer value of a hash field by the '
                        'given number'},
 'HINCRBYFLOAT': {'arguments': [{'name': 'key', 'type': 'key'},
                                {'name': 'field', 'type': 'string'},
                                {'name': 'increment', 'type': 'double'}],
                  'complexity': 'O(1)',
                  'group': 'hash',
                  'since': '2.6.0',
                  'summary': 'Increment the float value of a hash field by the '
                             'given amount'},
 'HKEYS': {'arguments': [{'name': 'key', 'type': 'key'}],
           'complexity': 'O(N) where N is the size of the hash.',
           'group': 'hash',
           'since': '2.0.0',
           'summary': 'Get all the fields in a hash'},
 'HLEN': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'hash',
          'since': '2.0.0',
          'summary': 'Get the number of fields in a hash'},
 'HMGET': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'multiple': True, 'name': 'field', 'type': 'string'}],
           'complexity': 'O(N) where N is the number of fields being '
                         'requested.',
           'group': 'hash',
           'since': '2.0.0',
           'summary': 'Get the values of all the given hash fields'},
 'HMSET': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'multiple': True,
                          'name': ['field', 'value'],
                          'type': ['string', 'string']}],
           'complexity': 'O(N) where N is the number of fields being set.',
           'group': 'hash',
           'since': '2.0.0',
           'summary': 'Set multiple hash fields to multiple values'},
 'HSCAN': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'cursor', 'type': 'integer'},
                         {'command': 'MATCH',
                          'name': 'pattern',
                          'optional': True,
                          'type': 'pattern'},
                         {'command': 'COUNT',
                          'name': 'count',
                          'optional': True,
                          'type': 'integer'}],
           'complexity': 'O(1) for every call. O(N) for a complete iteration, '
                         'including enough command calls for the cursor to '
                         'return back to 0. N is the number of elements inside '
                         'the collection..',
           'group': 'hash',
           'since': '2.8.0',
           'summary': 'Incrementally iterate hash fields and associated '
                      'values'},
 'HSET': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'field', 'type': 'string'},
                        {'name': 'value', 'type': 'string'}],
          'complexity': 'O(1)',
          'group': 'hash',
          'since': '2.0.0',
          'summary': 'Set the string value of a hash field'},
 'HSETNX': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'field', 'type': 'string'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'hash',
            'since': '2.0.0',
            'summary': 'Set the value of a hash field, only if the field does '
                       'not exist'},
 'HSTRLEN': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'field', 'type': 'string'}],
             'complexity': 'O(1)',
             'group': 'hash',
             'since': '3.2.0',
             'summary': 'Get the length of the value of a hash field'},
 'HVALS': {'arguments': [{'name': 'key', 'type': 'key'}],
           'complexity': 'O(N) where N is the size of the hash.',
           'group': 'hash',
           'since': '2.0.0',
           'summary': 'Get all the values in a hash'},
 'INCR': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'string',
          'since': '1.0.0',
          'summary': 'Increment the integer value of a key by one'},
 'INCRBY': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'increment', 'type': 'integer'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '1.0.0',
            'summary': 'Increment the integer value of a key by the given '
                       'amount'},
 'INCRBYFLOAT': {'arguments': [{'name': 'key', 'type': 'key'},
                               {'name': 'increment', 'type': 'double'}],
                 'complexity': 'O(1)',
                 'group': 'string',
                 'since': '2.6.0',
                 'summary': 'Increment the float value of a key by the given '
                            'amount'},
 'INFO': {'arguments': [{'name': 'section',
                         'optional': True,
                         'type': 'string'}],
          'group': 'server',
          'since': '1.0.0',
          'summary': 'Get information and statistics about the server'},
 'KEYS': {'arguments': [{'name': 'pattern', 'type': 'pattern'}],
          'complexity': 'O(N) with N being the number of keys in the database, '
                        'under the assumption that the key names in the '
                        'database and the given pattern have limited length.',
          'group': 'generic',
          'since': '1.0.0',
          'summary': 'Find all keys matching the given pattern'},
 'LASTSAVE': {'group': 'server',
              'since': '1.0.0',
              'summary': 'Get the UNIX time stamp of the last successful save '
                         'to disk'},
 'LINDEX': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'index', 'type': 'integer'}],
            'complexity': 'O(N) where N is the number of elements to traverse '
                          'to get to the element at index. This makes asking '
                          'for the first or the last element of the list O(1).',
            'group': 'list',
            'since': '1.0.0',
            'summary': 'Get an element from a list by its index'},
 'LINSERT': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'enum': ['BEFORE', 'AFTER'],
                            'name': 'where',
                            'type': 'enum'},
                           {'name': 'pivot', 'type': 'string'},
                           {'name': 'value', 'type': 'string'}],
             'complexity': 'O(N) where N is the number of elements to traverse '
                           'before seeing the value pivot. This means that '
                           'inserting somewhere on the left end on the list '
                           '(head) can be considered O(1) and inserting '
                           'somewhere on the right end (tail) is O(N).',
             'group': 'list',
             'since': '2.2.0',
             'summary': 'Insert an element before or after another element in '
                        'a list'},
 'LLEN': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'list',
          'since': '1.0.0',
          'summary': 'Get the length of a list'},
 'LPOP': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'list',
          'since': '1.0.0',
          'summary': 'Remove and get the first element in a list'},
 'LPUSH': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'multiple': True, 'name': 'value', 'type': 'string'}],
           'complexity': 'O(1)',
           'group': 'list',
           'since': '1.0.0',
           'summary': 'Prepend one or multiple values to a list'},
 'LPUSHX': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'list',
            'since': '2.2.0',
            'summary': 'Prepend a value to a list, only if the list exists'},
 'LRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'start', 'type': 'integer'},
                          {'name': 'stop', 'type': 'integer'}],
            'complexity': 'O(S+N) where S is the distance of start offset from '
                          'HEAD for small lists, from nearest end (HEAD or '
                          'TAIL) for large lists; and N is the number of '
                          'elements in the specified range.',
            'group': 'list',
            'since': '1.0.0',
            'summary': 'Get a range of elements from a list'},
 'LREM': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'count', 'type': 'integer'},
                        {'name': 'value', 'type': 'string'}],
          'complexity': 'O(N) where N is the length of the list.',
          'group': 'list',
          'since': '1.0.0',
          'summary': 'Remove elements from a list'},
 'LSET': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'index', 'type': 'integer'},
                        {'name': 'value', 'type': 'string'}],
          'complexity': 'O(N) where N is the length of the list. Setting '
                        'either the first or the last element of the list is '
                        'O(1).',
          'group': 'list',
          'since': '1.0.0',
          'summary': 'Set the value of an element in a list by its index'},
 'LTRIM': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'start', 'type': 'integer'},
                         {'name': 'stop', 'type': 'integer'}],
           'complexity': 'O(N) where N is the number of elements to be removed '
                         'by the operation.',
           'group': 'list',
           'since': '1.0.0',
           'summary': 'Trim a list to the specified range'},
 'MEMORY DOCTOR': {'group': 'server',
                   'since': '4.0.0',
                   'summary': 'Outputs memory problems report'},
 'MEMORY HELP': {'group': 'server',
                 'since': '4.0.0',
                 'summary': 'Show helpful text about the different '
                            'subcommands'},
 'MEMORY MALLOC-STATS': {'group': 'server',
                         'since': '4.0.0',
                         'summary': 'Show allocator internal stats'},
 'MEMORY PURGE': {'group': 'server',
                  'since': '4.0.0',
                  'summary': 'Ask the allocator to release memory'},
 'MEMORY STATS': {'group': 'server',
                  'since': '4.0.0',
                  'summary': 'Show memory usage details'},
 'MEMORY USAGE': {'arguments': [{'name': 'key', 'type': 'key'},
                                {'command': 'SAMPLES',
                                 'name': 'count',
                                 'optional': True,
                                 'type': 'integer'}],
                  'complexity': 'O(N) where N is the number of samples.',
                  'group': 'server',
                  'since': '4.0.0',
                  'summary': 'Estimate the memory usage of a key'},
 'MGET': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
          'complexity': 'O(N) where N is the number of keys to retrieve.',
          'group': 'string',
          'since': '1.0.0',
          'summary': 'Get the values of all the given keys'},
 'MIGRATE': {'arguments': [{'name': 'host', 'type': 'string'},
                           {'name': 'port', 'type': 'string'},
                           {'enum': ['key', '""'],
                            'name': 'key',
                            'type': 'enum'},
                           {'name': 'destination-db', 'type': 'integer'},
                           {'name': 'timeout', 'type': 'integer'},
                           {'enum': ['COPY'],
                            'name': 'copy',
                            'optional': True,
                            'type': 'enum'},
                           {'enum': ['REPLACE'],
                            'name': 'replace',
                            'optional': True,
                            'type': 'enum'},
                           {'command': 'KEYS',
                            'name': 'key',
                            'optional': True,
                            'type': 'key',
                            'variadic': True}],
             'complexity': 'This command actually executes a DUMP+DEL in the '
                           'source instance, and a RESTORE in the target '
                           'instance. See the pages of these commands for time '
                           'complexity. Also an O(N) data transfer between the '
                           'two instances is performed.',
             'group': 'generic',
             'since': '2.6.0',
             'summary': 'Atomically transfer a key from a Redis instance to '
                        'another one.'},
 'MONITOR': {'group': 'server',
             'since': '1.0.0',
             'summary': 'Listen for all requests received by the server in '
                        'real time'},
 'MOVE': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'db', 'type': 'integer'}],
          'complexity': 'O(1)',
          'group': 'generic',
          'since': '1.0.0',
          'summary': 'Move a key to another database'},
 'MSET': {'arguments': [{'multiple': True,
                         'name': ['key', 'value'],
                         'type': ['key', 'string']}],
          'complexity': 'O(N) where N is the number of keys to set.',
          'group': 'string',
          'since': '1.0.1',
          'summary': 'Set multiple keys to multiple values'},
 'MSETNX': {'arguments': [{'multiple': True,
                           'name': ['key', 'value'],
                           'type': ['key', 'string']}],
            'complexity': 'O(N) where N is the number of keys to set.',
            'group': 'string',
            'since': '1.0.1',
            'summary': 'Set multiple keys to multiple values, only if none of '
                       'the keys exist'},
 'MULTI': {'group': 'transactions',
           'since': '1.2.0',
           'summary': 'Mark the start of a transaction block'},
 'OBJECT': {'arguments': [{'name': 'subcommand', 'type': 'string'},
                          {'multiple': True,
                           'name': 'arguments',
                           'optional': True,
                           'type': 'string'}],
            'complexity': 'O(1) for all the currently implemented subcommands.',
            'group': 'generic',
            'since': '2.2.3',
            'summary': 'Inspect the internals of Redis objects'},
 'PERSIST': {'arguments': [{'name': 'key', 'type': 'key'}],
             'complexity': 'O(1)',
             'group': 'generic',
             'since': '2.2.0',
             'summary': 'Remove the expiration from a key'},
 'PEXPIRE': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'milliseconds', 'type': 'integer'}],
             'complexity': 'O(1)',
             'group': 'generic',
             'since': '2.6.0',
             'summary': "Set a key's time to live in milliseconds"},
 'PEXPIREAT': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'milliseconds-timestamp',
                              'type': 'posix time'}],
               'complexity': 'O(1)',
               'group': 'generic',
               'since': '2.6.0',
               'summary': 'Set the expiration for a key as a UNIX timestamp '
                          'specified in milliseconds'},
 'PFADD': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'multiple': True,
                          'name': 'element',
                          'type': 'string'}],
           'complexity': 'O(1) to add every element.',
           'group': 'hyperloglog',
           'since': '2.8.9',
           'summary': 'Adds the specified elements to the specified '
                      'HyperLogLog.'},
 'PFCOUNT': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
             'complexity': 'O(1) with a very small average constant time when '
                           'called with a single key. O(N) with N being the '
                           'number of keys, and much bigger constant times, '
                           'when called with multiple keys.',
             'group': 'hyperloglog',
             'since': '2.8.9',
             'summary': 'Return the approximated cardinality of the set(s) '
                        'observed by the HyperLogLog at key(s).'},
 'PFMERGE': {'arguments': [{'name': 'destkey', 'type': 'key'},
                           {'multiple': True,
                            'name': 'sourcekey',
                            'type': 'key'}],
             'complexity': 'O(N) to merge N HyperLogLogs, but with high '
                           'constant times.',
             'group': 'hyperloglog',
             'since': '2.8.9',
             'summary': 'Merge N different HyperLogLogs into a single one.'},
 'PING': {'arguments': [{'name': 'message',
                         'optional': True,
                         'type': 'string'}],
          'group': 'connection',
          'since': '1.0.0',
          'summary': 'Ping the server'},
 'PSETEX': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'milliseconds', 'type': 'integer'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '2.6.0',
            'summary': 'Set the value and expiration in milliseconds of a key'},
 'PSUBSCRIBE': {'arguments': [{'multiple': True,
                               'name': ['pattern'],
                               'type': ['pattern']}],
                'complexity': 'O(N) where N is the number of patterns the '
                              'client is already subscribed to.',
                'group': 'pubsub',
                'since': '2.0.0',
                'summary': 'Listen for messages published to channels matching '
                           'the given patterns'},
 'PTTL': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'generic',
          'since': '2.6.0',
          'summary': 'Get the time to live for a key in milliseconds'},
 'PUBLISH': {'arguments': [{'name': 'channel', 'type': 'string'},
                           {'name': 'message', 'type': 'string'}],
             'complexity': 'O(N+M) where N is the number of clients subscribed '
                           'to the receiving channel and M is the total number '
                           'of subscribed patterns (by any client).',
             'group': 'pubsub',
             'since': '2.0.0',
             'summary': 'Post a message to a channel'},
 'PUBSUB': {'arguments': [{'name': 'subcommand', 'type': 'string'},
                          {'multiple': True,
                           'name': 'argument',
                           'optional': True,
                           'type': 'string'}],
            'complexity': 'O(N) for the CHANNELS subcommand, where N is the '
                          'number of active channels, and assuming constant '
                          'time pattern matching (relatively short channels '
                          'and patterns). O(N) for the NUMSUB subcommand, '
                          'where N is the number of requested channels. O(1) '
                          'for the NUMPAT subcommand.',
            'group': 'pubsub',
            'since': '2.8.0',
            'summary': 'Inspect the state of the Pub/Sub subsystem'},
 'PUNSUBSCRIBE': {'arguments': [{'multiple': True,
                                 'name': 'pattern',
                                 'optional': True,
                                 'type': 'pattern'}],
                  'complexity': 'O(N+M) where N is the number of patterns the '
                                'client is already subscribed and M is the '
                                'number of total patterns subscribed in the '
                                'system (by any client).',
                  'group': 'pubsub',
                  'since': '2.0.0',
                  'summary': 'Stop listening for messages posted to channels '
                             'matching the given patterns'},
 'QUIT': {'group': 'connection',
          'since': '1.0.0',
          'summary': 'Close the connection'},
 'RANDOMKEY': {'complexity': 'O(1)',
               'group': 'generic',
               'since': '1.0.0',
               'summary': 'Return a random key from the keyspace'},
 'READONLY': {'complexity': 'O(1)',
              'group': 'cluster',
              'since': '3.0.0',
              'summary': 'Enables read queries for a connection to a cluster '
                         'replica node'},
 'READWRITE': {'complexity': 'O(1)',
               'group': 'cluster',
               'since': '3.0.0',
               'summary': 'Disables read queries for a connection to a cluster '
                          'replica node'},
 'RENAME': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'newkey', 'type': 'key'}],
            'complexity': 'O(1)',
            'group': 'generic',
            'since': '1.0.0',
            'summary': 'Rename a key'},
 'RENAMENX': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'newkey', 'type': 'key'}],
              'complexity': 'O(1)',
              'group': 'generic',
              'since': '1.0.0',
              'summary': 'Rename a key, only if the new key does not exist'},
 'REPLICAOF': {'arguments': [{'name': 'host', 'type': 'string'},
                             {'name': 'port', 'type': 'string'}],
               'group': 'server',
               'since': '5.0.0',
               'summary': 'Make the server a replica of another instance, or '
                          'promote it as master.'},
 'RESTORE': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'ttl', 'type': 'integer'},
                           {'name': 'serialized-value', 'type': 'string'},
                           {'enum': ['REPLACE'],
                            'name': 'replace',
                            'optional': True,
                            'type': 'enum'}],
             'complexity': 'O(1) to create the new key and additional O(N*M) '
                           'to reconstruct the serialized value, where N is '
                           'the number of Redis objects composing the value '
                           'and M their average size. For small string values '
                           'the time complexity is thus O(1)+O(1*M) where M is '
                           'small, so simply O(1). However for sorted set '
                           'values the complexity is O(N*M*log(N)) because '
                           'inserting values into sorted sets is O(log(N)).',
             'group': 'generic',
             'since': '2.6.0',
             'summary': 'Create a key using the provided serialized value, '
                        'previously obtained using DUMP.'},
 'ROLE': {'group': 'server',
          'since': '2.8.12',
          'summary': 'Return the role of the instance in the context of '
                     'replication'},
 'RPOP': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'list',
          'since': '1.0.0',
          'summary': 'Remove and get the last element in a list'},
 'RPOPLPUSH': {'arguments': [{'name': 'source', 'type': 'key'},
                             {'name': 'destination', 'type': 'key'}],
               'complexity': 'O(1)',
               'group': 'list',
               'since': '1.2.0',
               'summary': 'Remove the last element in a list, prepend it to '
                          'another list and return it'},
 'RPUSH': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'multiple': True, 'name': 'value', 'type': 'string'}],
           'complexity': 'O(1)',
           'group': 'list',
           'since': '1.0.0',
           'summary': 'Append one or multiple values to a list'},
 'RPUSHX': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'list',
            'since': '2.2.0',
            'summary': 'Append a value to a list, only if the list exists'},
 'SADD': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'multiple': True, 'name': 'member', 'type': 'string'}],
          'complexity': 'O(1) for each element added, so O(N) to add N '
                        'elements when the command is called with multiple '
                        'arguments.',
          'group': 'set',
          'since': '1.0.0',
          'summary': 'Add one or more members to a set'},
 'SAVE': {'group': 'server',
          'since': '1.0.0',
          'summary': 'Synchronously save the dataset to disk'},
 'SCAN': {'arguments': [{'name': 'cursor', 'type': 'integer'},
                        {'command': 'MATCH',
                         'name': 'pattern',
                         'optional': True,
                         'type': 'pattern'},
                        {'command': 'COUNT',
                         'name': 'count',
                         'optional': True,
                         'type': 'integer'}],
          'complexity': 'O(1) for every call. O(N) for a complete iteration, '
                        'including enough command calls for the cursor to '
                        'return back to 0. N is the number of elements inside '
                        'the collection.',
          'group': 'generic',
          'since': '2.8.0',
          'summary': 'Incrementally iterate the keys space'},
 'SCARD': {'arguments': [{'name': 'key', 'type': 'key'}],
           'complexity': 'O(1)',
           'group': 'set',
           'since': '1.0.0',
           'summary': 'Get the number of members in a set'},
 'SCRIPT DEBUG': {'arguments': [{'enum': ['YES', 'SYNC', 'NO'],
                                 'name': 'mode',
                                 'type': 'enum'}],
                  'complexity': 'O(1)',
                  'group': 'scripting',
                  'since': '3.2.0',
                  'summary': 'Set the debug mode for executed scripts.'},
 'SCRIPT EXISTS': {'arguments': [{'multiple': True,
                                  'name': 'sha1',
                                  'type': 'string'}],
                   'complexity': 'O(N) with N being the number of scripts to '
                                 'check (so checking a single script is an '
                                 'O(1) operation).',
                   'group': 'scripting',
                   'since': '2.6.0',
                   'summary': 'Check existence of scripts in the script '
                              'cache.'},
 'SCRIPT FLUSH': {'complexity': 'O(N) with N being the number of scripts in '
                                'cache',
                  'group': 'scripting',
                  'since': '2.6.0',
                  'summary': 'Remove all the scripts from the script cache.'},
 'SCRIPT KILL': {'complexity': 'O(1)',
                 'group': 'scripting',
                 'since': '2.6.0',
                 'summary': 'Kill the script currently in execution.'},
 'SCRIPT LOAD': {'arguments': [{'name': 'script', 'type': 'string'}],
                 'complexity': 'O(N) with N being the length in bytes of the '
                               'script body.',
                 'group': 'scripting',
                 'since': '2.6.0',
                 'summary': 'Load the specified Lua script into the script '
                            'cache.'},
 'SDIFF': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
           'complexity': 'O(N) where N is the total number of elements in all '
                         'given sets.',
           'group': 'set',
           'since': '1.0.0',
           'summary': 'Subtract multiple sets'},
 'SDIFFSTORE': {'arguments': [{'name': 'destination', 'type': 'key'},
                              {'multiple': True, 'name': 'key', 'type': 'key'}],
                'complexity': 'O(N) where N is the total number of elements in '
                              'all given sets.',
                'group': 'set',
                'since': '1.0.0',
                'summary': 'Subtract multiple sets and store the resulting set '
                           'in a key'},
 'SELECT': {'arguments': [{'name': 'index', 'type': 'integer'}],
            'group': 'connection',
            'since': '1.0.0',
            'summary': 'Change the selected database for the current '
                       'connection'},
 'SET': {'arguments': [{'name': 'key', 'type': 'key'},
                       {'name': 'value', 'type': 'string'},
                       {'command': 'expiration',
                        'enum': ['EX seconds', 'PX milliseconds'],
                        'optional': True,
                        'type': 'enum'},
                       {'enum': ['NX', 'XX'],
                        'name': 'condition',
                        'optional': True,
                        'type': 'enum'}],
         'complexity': 'O(1)',
         'group': 'string',
         'since': '1.0.0',
         'summary': 'Set the string value of a key'},
 'SETBIT': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'offset', 'type': 'integer'},
                          {'name': 'value', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '2.2.0',
            'summary': 'Sets or clears the bit at offset in the string value '
                       'stored at key'},
 'SETEX': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'seconds', 'type': 'integer'},
                         {'name': 'value', 'type': 'string'}],
           'complexity': 'O(1)',
           'group': 'string',
           'since': '2.0.0',
           'summary': 'Set the value and expiration of a key'},
 'SETNX': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'value', 'type': 'string'}],
           'complexity': 'O(1)',
           'group': 'string',
           'since': '1.0.0',
           'summary': 'Set the value of a key, only if the key does not exist'},
 'SETRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'offset', 'type': 'integer'},
                            {'name': 'value', 'type': 'string'}],
              'complexity': 'O(1), not counting the time taken to copy the new '
                            'string in place. Usually, this string is very '
                            'small so the amortized complexity is O(1). '
                            'Otherwise, complexity is O(M) with M being the '
                            'length of the value argument.',
              'group': 'string',
              'since': '2.2.0',
              'summary': 'Overwrite part of a string at key starting at the '
                         'specified offset'},
 'SHUTDOWN': {'arguments': [{'enum': ['NOSAVE', 'SAVE'],
                             'name': 'save-mode',
                             'optional': True,
                             'type': 'enum'}],
              'group': 'server',
              'since': '1.0.0',
              'summary': 'Synchronously save the dataset to disk and then shut '
                         'down the server'},
 'SINTER': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
            'complexity': 'O(N*M) worst case where N is the cardinality of the '
                          'smallest set and M is the number of sets.',
            'group': 'set',
            'since': '1.0.0',
            'summary': 'Intersect multiple sets'},
 'SINTERSTORE': {'arguments': [{'name': 'destination', 'type': 'key'},
                               {'multiple': True,
                                'name': 'key',
                                'type': 'key'}],
                 'complexity': 'O(N*M) worst case where N is the cardinality '
                               'of the smallest set and M is the number of '
                               'sets.',
                 'group': 'set',
                 'since': '1.0.0',
                 'summary': 'Intersect multiple sets and store the resulting '
                            'set in a key'},
 'SISMEMBER': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'member', 'type': 'string'}],
               'complexity': 'O(1)',
               'group': 'set',
               'since': '1.0.0',
               'summary': 'Determine if a given value is a member of a set'},
 'SLAVEOF': {'arguments': [{'name': 'host', 'type': 'string'},
                           {'name': 'port', 'type': 'string'}],
             'group': 'server',
             'since': '1.0.0',
             'summary': 'Make the server a replica of another instance, or '
                        'promote it as master. Deprecated starting with Redis '
                        '5. Use REPLICAOF instead.'},
 'SLOWLOG': {'arguments': [{'name': 'subcommand', 'type': 'string'},
                           {'name': 'argument',
                            'optional': True,
                            'type': 'string'}],
             'group': 'server',
             'since': '2.2.12',
             'summary': 'Manages the Redis slow queries log'},
 'SMEMBERS': {'arguments': [{'name': 'key', 'type': 'key'}],
              'complexity': 'O(N) where N is the set cardinality.',
              'group': 'set',
              'since': '1.0.0',
              'summary': 'Get all the members in a set'},
 'SMOVE': {'arguments': [{'name': 'source', 'type': 'key'},
                         {'name': 'destination', 'type': 'key'},
                         {'name': 'member', 'type': 'string'}],
           'complexity': 'O(1)',
           'group': 'set',
           'since': '1.0.0',
           'summary': 'Move a member from one set to another'},
 'SORT': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'command': 'BY',
                         'name': 'pattern',
                         'optional': True,
                         'type': 'pattern'},
                        {'command': 'LIMIT',
                         'name': ['offset', 'count'],
                         'optional': True,
                         'type': ['integer', 'integer']},
                        {'command': 'GET',
                         'multiple': True,
                         'name': 'pattern',
                         'optional': True,
                         'type': 'string'},
                        {'enum': ['ASC', 'DESC'],
                         'name': 'order',
                         'optional': True,
                         'type': 'enum'},
                        {'enum': ['ALPHA'],
                         'name': 'sorting',
                         'optional': True,
                         'type': 'enum'},
                        {'command': 'STORE',
                         'name': 'destination',
                         'optional': True,
                         'type': 'key'}],
          'complexity': 'O(N+M*log(M)) where N is the number of elements in '
                        'the list or set to sort, and M the number of returned '
                        'elements. When the elements are not sorted, '
                        'complexity is currently O(N) as there is a copy step '
                        'that will be avoided in next releases.',
          'group': 'generic',
          'since': '1.0.0',
          'summary': 'Sort the elements in a list, set or sorted set'},
 'SPOP': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'count', 'optional': True, 'type': 'integer'}],
          'complexity': 'O(1)',
          'group': 'set',
          'since': '1.0.0',
          'summary': 'Remove and return one or multiple random members from a '
                     'set'},
 'SRANDMEMBER': {'arguments': [{'name': 'key', 'type': 'key'},
                               {'name': 'count',
                                'optional': True,
                                'type': 'integer'}],
                 'complexity': 'Without the count argument O(1), otherwise '
                               'O(N) where N is the absolute value of the '
                               'passed count.',
                 'group': 'set',
                 'since': '1.0.0',
                 'summary': 'Get one or multiple random members from a set'},
 'SREM': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'multiple': True, 'name': 'member', 'type': 'string'}],
          'complexity': 'O(N) where N is the number of members to be removed.',
          'group': 'set',
          'since': '1.0.0',
          'summary': 'Remove one or more members from a set'},
 'SSCAN': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'cursor', 'type': 'integer'},
                         {'command': 'MATCH',
                          'name': 'pattern',
                          'optional': True,
                          'type': 'pattern'},
                         {'command': 'COUNT',
                          'name': 'count',
                          'optional': True,
                          'type': 'integer'}],
           'complexity': 'O(1) for every call. O(N) for a complete iteration, '
                         'including enough command calls for the cursor to '
                         'return back to 0. N is the number of elements inside '
                         'the collection..',
           'group': 'set',
           'since': '2.8.0',
           'summary': 'Incrementally iterate Set elements'},
 'STRLEN': {'arguments': [{'name': 'key', 'type': 'key'}],
            'complexity': 'O(1)',
            'group': 'string',
            'since': '2.2.0',
            'summary': 'Get the length of the value stored in a key'},
 'SUBSCRIBE': {'arguments': [{'multiple': True,
                              'name': ['channel'],
                              'type': ['string']}],
               'complexity': 'O(N) where N is the number of channels to '
                             'subscribe to.',
               'group': 'pubsub',
               'since': '2.0.0',
               'summary': 'Listen for messages published to the given '
                          'channels'},
 'SUNION': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
            'complexity': 'O(N) where N is the total number of elements in all '
                          'given sets.',
            'group': 'set',
            'since': '1.0.0',
            'summary': 'Add multiple sets'},
 'SUNIONSTORE': {'arguments': [{'name': 'destination', 'type': 'key'},
                               {'multiple': True,
                                'name': 'key',
                                'type': 'key'}],
                 'complexity': 'O(N) where N is the total number of elements '
                               'in all given sets.',
                 'group': 'set',
                 'since': '1.0.0',
                 'summary': 'Add multiple sets and store the resulting set in '
                            'a key'},
 'SWAPDB': {'arguments': [{'name': 'index', 'type': 'integer'},
                          {'name': 'index', 'type': 'integer'}],
            'group': 'connection',
            'since': '4.0.0',
            'summary': 'Swaps two Redis databases'},
 'SYNC': {'group': 'server',
          'since': '1.0.0',
          'summary': 'Internal command used for replication'},
 'TIME': {'complexity': 'O(1)',
          'group': 'server',
          'since': '2.6.0',
          'summary': 'Return the current server time'},
 'TOUCH': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
           'complexity': 'O(N) where N is the number of keys that will be '
                         'touched.',
           'group': 'generic',
           'since': '3.2.1',
           'summary': 'Alters the last access time of a key(s). Returns the '
                      'number of existing keys specified.'},
 'TTL': {'arguments': [{'name': 'key', 'type': 'key'}],
         'complexity': 'O(1)',
         'group': 'generic',
         'since': '1.0.0',
         'summary': 'Get the time to live for a key'},
 'TYPE': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'generic',
          'since': '1.0.0',
          'summary': 'Determine the type stored at key'},
 'UNLINK': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
            'complexity': 'O(1) for each key removed regardless of its size. '
                          'Then the command does O(N) work in a different '
                          'thread in order to reclaim memory, where N is the '
                          'number of allocations the deleted objects where '
                          'composed of.',
            'group': 'generic',
            'since': '4.0.0',
            'summary': 'Delete a key asynchronously in another thread. '
                       'Otherwise it is just as DEL, but non blocking.'},
 'UNSUBSCRIBE': {'arguments': [{'multiple': True,
                                'name': 'channel',
                                'optional': True,
                                'type': 'string'}],
                 'complexity': 'O(N) where N is the number of clients already '
                               'subscribed to a channel.',
                 'group': 'pubsub',
                 'since': '2.0.0',
                 'summary': 'Stop listening for messages posted to the given '
                            'channels'},
 'UNWATCH': {'complexity': 'O(1)',
             'group': 'transactions',
             'since': '2.2.0',
             'summary': 'Forget about all watched keys'},
 'WAIT': {'arguments': [{'name': 'numreplicas', 'type': 'integer'},
                        {'name': 'timeout', 'type': 'integer'}],
          'complexity': 'O(1)',
          'group': 'generic',
          'since': '3.0.0',
          'summary': 'Wait for the synchronous replication of all the write '
                     'commands sent in the context of the current connection'},
 'WATCH': {'arguments': [{'multiple': True, 'name': 'key', 'type': 'key'}],
           'complexity': 'O(1) for every key.',
           'group': 'transactions',
           'since': '2.2.0',
           'summary': 'Watch the given keys to determine execution of the '
                      'MULTI/EXEC block'},
 'XACK': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'group', 'type': 'string'},
                        {'multiple': True, 'name': 'ID', 'type': 'string'}],
          'complexity': 'O(1) for each message ID processed.',
          'group': 'stream',
          'since': '5.0.0',
          'summary': 'Marks a pending message as correctly processed, '
                     'effectively removing it from the pending entries list of '
                     'the consumer group. Return value of the command is the '
                     'number of messages successfully acknowledged, that is, '
                     'the IDs we were actually able to resolve in the PEL.'},
 'XADD': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'name': 'ID', 'type': 'string'},
                        {'multiple': True,
                         'name': ['field', 'string'],
                         'type': ['value', 'string']}],
          'complexity': 'O(1) but with non trivial constant times',
          'group': 'stream',
          'since': '5.0.0',
          'summary': 'Appends a new entry to a stream'},
 'XCLAIM': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'group', 'type': 'string'},
                          {'name': 'consumer', 'type': 'string'},
                          {'name': 'min-idle-time', 'type': 'string'},
                          {'multiple': True, 'name': 'ID', 'type': 'string'},
                          {'command': 'IDLE',
                           'name': 'ms',
                           'optional': True,
                           'type': 'integer'},
                          {'command': 'TIME',
                           'name': 'ms-unix-time',
                           'optional': True,
                           'type': 'integer'},
                          {'command': 'RETRYCOUNT',
                           'name': 'count',
                           'optional': True,
                           'type': 'integer'},
                          {'enum': ['FORCE'],
                           'name': 'force',
                           'optional': True},
                          {'enum': ['JUSTID'],
                           'name': 'justid',
                           'optional': True}],
            'complexity': 'O(log N) with N being the number of messages in the '
                          'PEL of the consumer group.',
            'group': 'stream',
            'since': '5.0.0',
            'summary': 'Changes (or acquires) ownership of a message in a '
                       'consumer group, as if the message was delivered to the '
                       'specified consumer.'},
 'XDEL': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'multiple': 'true', 'name': 'ID', 'type': 'string'}],
          'complexity': 'O(1) for each single item to delete in the stream, '
                        'regardless of the stream size.',
          'group': 'stream',
          'since': '5.0.0',
          'summary': 'Removes the specified entries from the stream. Returns '
                     'the number of items actually deleted, that may be '
                     'different from the number of IDs passed in case certain '
                     'IDs do not exist.'},
 'XGROUP': {'arguments': [{'command': 'CREATE',
                           'name': ['key', 'groupname', 'id-or-$'],
                           'optional': True,
                           'type': ['key', 'string', 'string']},
                          {'command': 'SETID',
                           'name': ['key', 'groupname', 'id-or-$'],
                           'optional': True,
                           'type': ['key', 'string', 'string']},
                          {'command': 'DESTROY',
                           'name': ['key', 'groupname'],
                           'optional': True,
                           'type': ['key', 'string']},
                          {'command': 'DELCONSUMER',
                           'name': ['key', 'groupname', 'consumername'],
                           'optional': True,
                           'type': ['key', 'string', 'string']}],
            'complexity': 'O(1) for all the subcommands, with the exception of '
                          'the DESTROY subcommand which takes an additional '
                          'O(M) time in order to delete the M entries inside '
                          'the consumer group pending entries list (PEL).',
            'group': 'stream',
            'since': '5.0.0',
            'summary': 'Create, destroy, and manage consumer groups.'},
 'XINFO': {'arguments': [{'command': 'CONSUMERS',
                          'name': ['key', 'groupname'],
                          'optional': True,
                          'type': ['key', 'string']},
                         {'command': 'GROUPS',
                          'name': 'key',
                          'optional': True,
                          'type': 'key'},
                         {'command': 'STREAM',
                          'name': 'key',
                          'optional': True,
                          'type': 'key'},
                         {'enum': ['HELP'],
                          'name': 'help',
                          'optional': True,
                          'type': 'enum'}],
           'complexity': 'O(N) with N being the number of returned items for '
                         'the subcommands CONSUMERS and GROUPS. The STREAM '
                         'subcommand is O(log N) with N being the number of '
                         'items in the stream.',
           'group': 'stream',
           'since': '5.0.0',
           'summary': 'Get information on streams and consumer groups'},
 'XLEN': {'arguments': [{'name': 'key', 'type': 'key'}],
          'complexity': 'O(1)',
          'group': 'stream',
          'since': '5.0.0',
          'summary': 'Return the number of entires in a stream'},
 'XPENDING': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'group', 'type': 'string'},
                            {'name': ['start', 'end', 'count'],
                             'optional': True,
                             'type': ['string', 'string', 'integer']},
                            {'name': 'consumer',
                             'optional': True,
                             'type': 'string'}],
              'complexity': 'O(N) with N being the number of elements '
                            'returned, so asking for a small fixed number of '
                            'entries per call is O(1). When the command '
                            'returns just the summary it runs in O(1) time '
                            'assuming the list of consumers is small, '
                            'otherwise there is additional O(N) time needed to '
                            'iterate every consumer.',
              'group': 'stream',
              'since': '5.0.0',
              'summary': 'Return information and entries from a stream '
                         'consumer group pending entries list, that are '
                         'messages fetched but never acknowledged.'},
 'XRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'start', 'type': 'string'},
                          {'name': 'end', 'type': 'string'},
                          {'command': 'COUNT',
                           'name': 'count',
                           'optional': True,
                           'type': 'integer'}],
            'complexity': 'O(N) with N being the number of elements being '
                          'returned. If N is constant (e.g. always asking for '
                          'the first 10 elements with COUNT), you can consider '
                          'it O(1).',
            'group': 'stream',
            'since': '5.0.0',
            'summary': 'Return a range of elements in a stream, with IDs '
                       'matching the specified IDs interval'},
 'XREAD': {'arguments': [{'command': 'COUNT',
                          'name': 'count',
                          'optional': True,
                          'type': 'integer'},
                         {'command': 'BLOCK',
                          'name': 'milliseconds',
                          'optional': True,
                          'type': 'integer'},
                         {'enum': ['STREAMS'],
                          'name': 'streams',
                          'type': 'enum'},
                         {'multiple': True, 'name': 'key', 'type': 'key'},
                         {'multiple': True, 'name': 'ID', 'type': 'string'}],
           'complexity': 'For each stream mentioned: O(N) with N being the '
                         'number of elements being returned, it menas that '
                         'XREAD-ing with a fixed COUNT is O(1), even if with '
                         'non-trivial constant times. Note that when the BLOCK '
                         'option is used, XADD will pay O(M) time in order to '
                         'serve the M clients blocked on the stream getting '
                         'new data.',
           'group': 'stream',
           'since': '5.0.0',
           'summary': 'Return never seen elements in multiple streams, with '
                      'IDs greater than the ones reported by the caller for '
                      'each stream. Can block.'},
 'XREADGROUP': {'arguments': [{'command': 'GROUP',
                               'name': ['group', 'consumer'],
                               'type': ['string', 'string']},
                              {'command': 'COUNT',
                               'name': 'count',
                               'optional': True,
                               'type': 'integer'},
                              {'command': 'BLOCK',
                               'name': 'milliseconds',
                               'optional': True,
                               'type': 'integer'},
                              {'enum': ['NOACK'],
                               'name': 'noack',
                               'optional': True,
                               'type': 'enum'},
                              {'enum': ['STREAMS'],
                               'name': 'streams',
                               'type': 'enum'},
                              {'multiple': True, 'name': 'key', 'type': 'key'},
                              {'multiple': True,
                               'name': 'ID',
                               'type': 'string'}],
                'complexity': 'For each stream mentioned: O(M) with M being '
                              'the number of elements returned. If M is '
                              'constant (e.g. always asking for the first 10 '
                              'elements with COUNT), you can consider it O(1). '
                              'On the other side when XREADGROUP blocks, XADD '
                              'will pay the O(N) time in order to serve the N '
                              'clients blocked on the stream getting new data.',
                'group': 'stream',
                'since': '5.0.0',
                'summary': 'Return new entries from a stream using a consumer '
                           'group, or access the history of the pending '
                           'entries for a given consumer. Can block.'},
 'XREVRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'end', 'type': 'string'},
                             {'name': 'start', 'type': 'string'},
                             {'command': 'COUNT',
                              'name': 'count',
                              'optional': True,
                              'type': 'integer'}],
               'complexity': 'O(N) with N being the number of elements '
                             'returned. If N is constant (e.g. always asking '
                             'for the first 10 elements with COUNT), you can '
                             'consider it O(1).',
               'group': 'stream',
               'since': '5.0.0',
               'summary': 'Return a range of elements in a stream, with IDs '
                          'matching the specified IDs interval, in reverse '
                          'order (from greater to smaller IDs) compared to '
                          'XRANGE'},
 'XTRIM': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'enum': ['MAXLEN'],
                          'name': 'strategy',
                          'type': 'enum'},
                         {'enum': ['~'],
                          'name': 'approx',
                          'optional': True,
                          'type': 'enum'},
                         {'name': 'count', 'type': 'integer'}],
           'complexity': 'O(N), with N being the number of evicted entries. '
                         'Constant times are very small however, since entries '
                         'are organized in macro nodes containing multiple '
                         'entries that can be released with a single '
                         'deallocation.',
           'group': 'stream',
           'since': '5.0.0',
           'summary': "Trims the stream to (approximately if '~' is passed) a "
                      'certain size'},
 'ZADD': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'enum': ['NX', 'XX'],
                         'name': 'condition',
                         'optional': True,
                         'type': 'enum'},
                        {'enum': ['CH'],
                         'name': 'change',
                         'optional': True,
                         'type': 'enum'},
                        {'enum': ['INCR'],
                         'name': 'increment',
                         'optional': True,
                         'type': 'enum'},
                        {'multiple': True,
                         'name': ['score', 'member'],
                         'type': ['double', 'string']}],
          'complexity': 'O(log(N)) for each item added, where N is the number '
                        'of elements in the sorted set.',
          'group': 'sorted_set',
          'since': '1.2.0',
          'summary': 'Add one or more members to a sorted set, or update its '
                     'score if it already exists'},
 'ZCARD': {'arguments': [{'name': 'key', 'type': 'key'}],
           'complexity': 'O(1)',
           'group': 'sorted_set',
           'since': '1.2.0',
           'summary': 'Get the number of members in a sorted set'},
 'ZCOUNT': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'min', 'type': 'double'},
                          {'name': 'max', 'type': 'double'}],
            'complexity': 'O(log(N)) with N being the number of elements in '
                          'the sorted set.',
            'group': 'sorted_set',
            'since': '2.0.0',
            'summary': 'Count the members in a sorted set with scores within '
                       'the given values'},
 'ZINCRBY': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'increment', 'type': 'integer'},
                           {'name': 'member', 'type': 'string'}],
             'complexity': 'O(log(N)) where N is the number of elements in the '
                           'sorted set.',
             'group': 'sorted_set',
             'since': '1.2.0',
             'summary': 'Increment the score of a member in a sorted set'},
 'ZINTERSTORE': {'arguments': [{'name': 'destination', 'type': 'key'},
                               {'name': 'numkeys', 'type': 'integer'},
                               {'multiple': True, 'name': 'key', 'type': 'key'},
                               {'command': 'WEIGHTS',
                                'name': 'weight',
                                'optional': True,
                                'type': 'integer',
                                'variadic': True},
                               {'command': 'AGGREGATE',
                                'enum': ['SUM', 'MIN', 'MAX'],
                                'name': 'aggregate',
                                'optional': True,
                                'type': 'enum'}],
                 'complexity': 'O(N*K)+O(M*log(M)) worst case with N being the '
                               'smallest input sorted set, K being the number '
                               'of input sorted sets and M being the number of '
                               'elements in the resulting sorted set.',
                 'group': 'sorted_set',
                 'since': '2.0.0',
                 'summary': 'Intersect multiple sorted sets and store the '
                            'resulting sorted set in a new key'},
 'ZLEXCOUNT': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'min', 'type': 'string'},
                             {'name': 'max', 'type': 'string'}],
               'complexity': 'O(log(N)) with N being the number of elements in '
                             'the sorted set.',
               'group': 'sorted_set',
               'since': '2.8.9',
               'summary': 'Count the number of members in a sorted set between '
                          'a given lexicographical range'},
 'ZPOPMAX': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'count',
                            'optional': True,
                            'type': 'integer'}],
             'complexity': 'O(log(N)*M) with N being the number of elements in '
                           'the sorted set, and M being the number of elements '
                           'popped.',
             'group': 'sorted_set',
             'since': '5.0.0',
             'summary': 'Remove and return members with the highest scores in '
                        'a sorted set'},
 'ZPOPMIN': {'arguments': [{'name': 'key', 'type': 'key'},
                           {'name': 'count',
                            'optional': True,
                            'type': 'integer'}],
             'complexity': 'O(log(N)*M) with N being the number of elements in '
                           'the sorted set, and M being the number of elements '
                           'popped.',
             'group': 'sorted_set',
             'since': '5.0.0',
             'summary': 'Remove and return members with the lowest scores in a '
                        'sorted set'},
 'ZRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'start', 'type': 'integer'},
                          {'name': 'stop', 'type': 'integer'},
                          {'enum': ['WITHSCORES'],
                           'name': 'withscores',
                           'optional': True,
                           'type': 'enum'}],
            'complexity': 'O(log(N)+M) with N being the number of elements in '
                          'the sorted set and M the number of elements '
                          'returned.',
            'group': 'sorted_set',
            'since': '1.2.0',
            'summary': 'Return a range of members in a sorted set, by index'},
 'ZRANGEBYLEX': {'arguments': [{'name': 'key', 'type': 'key'},
                               {'name': 'min', 'type': 'string'},
                               {'name': 'max', 'type': 'string'},
                               {'command': 'LIMIT',
                                'name': ['offset', 'count'],
                                'optional': True,
                                'type': ['integer', 'integer']}],
                 'complexity': 'O(log(N)+M) with N being the number of '
                               'elements in the sorted set and M the number of '
                               'elements being returned. If M is constant '
                               '(e.g. always asking for the first 10 elements '
                               'with LIMIT), you can consider it O(log(N)).',
                 'group': 'sorted_set',
                 'since': '2.8.9',
                 'summary': 'Return a range of members in a sorted set, by '
                            'lexicographical range'},
 'ZRANGEBYSCORE': {'arguments': [{'name': 'key', 'type': 'key'},
                                 {'name': 'min', 'type': 'double'},
                                 {'name': 'max', 'type': 'double'},
                                 {'enum': ['WITHSCORES'],
                                  'name': 'withscores',
                                  'optional': True,
                                  'type': 'enum'},
                                 {'command': 'LIMIT',
                                  'name': ['offset', 'count'],
                                  'optional': True,
                                  'type': ['integer', 'integer']}],
                   'complexity': 'O(log(N)+M) with N being the number of '
                                 'elements in the sorted set and M the number '
                                 'of elements being returned. If M is constant '
                                 '(e.g. always asking for the first 10 '
                                 'elements with LIMIT), you can consider it '
                                 'O(log(N)).',
                   'group': 'sorted_set',
                   'since': '1.0.5',
                   'summary': 'Return a range of members in a sorted set, by '
                              'score'},
 'ZRANK': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'member', 'type': 'string'}],
           'complexity': 'O(log(N))',
           'group': 'sorted_set',
           'since': '2.0.0',
           'summary': 'Determine the index of a member in a sorted set'},
 'ZREM': {'arguments': [{'name': 'key', 'type': 'key'},
                        {'multiple': True, 'name': 'member', 'type': 'string'}],
          'complexity': 'O(M*log(N)) with N being the number of elements in '
                        'the sorted set and M the number of elements to be '
                        'removed.',
          'group': 'sorted_set',
          'since': '1.2.0',
          'summary': 'Remove one or more members from a sorted set'},
 'ZREMRANGEBYLEX': {'arguments': [{'name': 'key', 'type': 'key'},
                                  {'name': 'min', 'type': 'string'},
                                  {'name': 'max', 'type': 'string'}],
                    'complexity': 'O(log(N)+M) with N being the number of '
                                  'elements in the sorted set and M the number '
                                  'of elements removed by the operation.',
                    'group': 'sorted_set',
                    'since': '2.8.9',
                    'summary': 'Remove all members in a sorted set between the '
                               'given lexicographical range'},
 'ZREMRANGEBYRANK': {'arguments': [{'name': 'key', 'type': 'key'},
                                   {'name': 'start', 'type': 'integer'},
                                   {'name': 'stop', 'type': 'integer'}],
                     'complexity': 'O(log(N)+M) with N being the number of '
                                   'elements in the sorted set and M the '
                                   'number of elements removed by the '
                                   'operation.',
                     'group': 'sorted_set',
                     'since': '2.0.0',
                     'summary': 'Remove all members in a sorted set within the '
                                'given indexes'},
 'ZREMRANGEBYSCORE': {'arguments': [{'name': 'key', 'type': 'key'},
                                    {'name': 'min', 'type': 'double'},
                                    {'name': 'max', 'type': 'double'}],
                      'complexity': 'O(log(N)+M) with N being the number of '
                                    'elements in the sorted set and M the '
                                    'number of elements removed by the '
                                    'operation.',
                      'group': 'sorted_set',
                      'since': '1.2.0',
                      'summary': 'Remove all members in a sorted set within '
                                 'the given scores'},
 'ZREVRANGE': {'arguments': [{'name': 'key', 'type': 'key'},
                             {'name': 'start', 'type': 'integer'},
                             {'name': 'stop', 'type': 'integer'},
                             {'enum': ['WITHSCORES'],
                              'name': 'withscores',
                              'optional': True,
                              'type': 'enum'}],
               'complexity': 'O(log(N)+M) with N being the number of elements '
                             'in the sorted set and M the number of elements '
                             'returned.',
               'group': 'sorted_set',
               'since': '1.2.0',
               'summary': 'Return a range of members in a sorted set, by '
                          'index, with scores ordered from high to low'},
 'ZREVRANGEBYLEX': {'arguments': [{'name': 'key', 'type': 'key'},
                                  {'name': 'max', 'type': 'string'},
                                  {'name': 'min', 'type': 'string'},
                                  {'command': 'LIMIT',
                                   'name': ['offset', 'count'],
                                   'optional': True,
                                   'type': ['integer', 'integer']}],
                    'complexity': 'O(log(N)+M) with N being the number of '
                                  'elements in the sorted set and M the number '
                                  'of elements being returned. If M is '
                                  'constant (e.g. always asking for the first '
                                  '10 elements with LIMIT), you can consider '
                                  'it O(log(N)).',
                    'group': 'sorted_set',
                    'since': '2.8.9',
                    'summary': 'Return a range of members in a sorted set, by '
                               'lexicographical range, ordered from higher to '
                               'lower strings.'},
 'ZREVRANGEBYSCORE': {'arguments': [{'name': 'key', 'type': 'key'},
                                    {'name': 'max', 'type': 'double'},
                                    {'name': 'min', 'type': 'double'},
                                    {'enum': ['WITHSCORES'],
                                     'name': 'withscores',
                                     'optional': True,
                                     'type': 'enum'},
                                    {'command': 'LIMIT',
                                     'name': ['offset', 'count'],
                                     'optional': True,
                                     'type': ['integer', 'integer']}],
                      'complexity': 'O(log(N)+M) with N being the number of '
                                    'elements in the sorted set and M the '
                                    'number of elements being returned. If M '
                                    'is constant (e.g. always asking for the '
                                    'first 10 elements with LIMIT), you can '
                                    'consider it O(log(N)).',
                      'group': 'sorted_set',
                      'since': '2.2.0',
                      'summary': 'Return a range of members in a sorted set, '
                                 'by score, with scores ordered from high to '
                                 'low'},
 'ZREVRANK': {'arguments': [{'name': 'key', 'type': 'key'},
                            {'name': 'member', 'type': 'string'}],
              'complexity': 'O(log(N))',
              'group': 'sorted_set',
              'since': '2.0.0',
              'summary': 'Determine the index of a member in a sorted set, '
                         'with scores ordered from high to low'},
 'ZSCAN': {'arguments': [{'name': 'key', 'type': 'key'},
                         {'name': 'cursor', 'type': 'integer'},
                         {'command': 'MATCH',
                          'name': 'pattern',
                          'optional': True,
                          'type': 'pattern'},
                         {'command': 'COUNT',
                          'name': 'count',
                          'optional': True,
                          'type': 'integer'}],
           'complexity': 'O(1) for every call. O(N) for a complete iteration, '
                         'including enough command calls for the cursor to '
                         'return back to 0. N is the number of elements inside '
                         'the collection..',
           'group': 'sorted_set',
           'since': '2.8.0',
           'summary': 'Incrementally iterate sorted sets elements and '
                      'associated scores'},
 'ZSCORE': {'arguments': [{'name': 'key', 'type': 'key'},
                          {'name': 'member', 'type': 'string'}],
            'complexity': 'O(1)',
            'group': 'sorted_set',
            'since': '1.2.0',
            'summary': 'Get the score associated with the given member in a '
                       'sorted set'},
 'ZUNIONSTORE': {'arguments': [{'name': 'destination', 'type': 'key'},
                               {'name': 'numkeys', 'type': 'integer'},
                               {'multiple': True, 'name': 'key', 'type': 'key'},
                               {'command': 'WEIGHTS',
                                'name': 'weight',
                                'optional': True,
                                'type': 'integer',
                                'variadic': True},
                               {'command': 'AGGREGATE',
                                'enum': ['SUM', 'MIN', 'MAX'],
                                'name': 'aggregate',
                                'optional': True,
                                'type': 'enum'}],
                 'complexity': 'O(N)+O(M log(M)) with N being the sum of the '
                               'sizes of the input sorted sets, and M being '
                               'the number of elements in the resulting sorted '
                               'set.',
                 'group': 'sorted_set',
                 'since': '2.0.0',
                 'summary': 'Add multiple sorted sets and store the resulting '
                            'sorted set in a new key'}}